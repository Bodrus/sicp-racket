#lang racket/base
(require "../../../../lib/bace.rkt")
(require "../../../../lib/list.rkt")

;;; Упражнение 2.20.
;;; Процедуры +, * и list принимают произвольное число аргументов. Один из способов опреде-
;;; ления таких процедур состоит в использовании точечной записи (dotted-tail notation). В опре-
;;; делении процедуры список параметров с точкой перед именем последнего члена означает, что,
;;; когда процедура вызывается, начальные параметры (если они есть) будут иметь в качестве значе-
;;; ний начальные аргументы, как и обычно, но значением последнего параметра будет список всех
;;; оставшихся аргументов. Например, если дано определение

;;; (define (f x y . z) [тело])

;;; то процедуру f можно вызывать с двумя и более аргументами. Если мы вычисляем
;;; (f 1 2 3 4 5 6)
;;; то в теле f переменная x будет равна 1, y будет равно 2, а z будет списком (3 4 5 6). Если дано
;;; определение

;;; (define (g . w) [тело])

;;; то процедура g может вызываться с нулем и более аргументов. Если мы вычислим
;;; (g 1 2 3 4 5 6)
;;; то в теле g значением переменной w будет список (1 2 3 4 5 6) 11 .
;;; Используя эту нотацию, напишите процедуру same-parity, которая принимает одно или
;;; более целое число и возвращает список всех тех аргументов, у которых четность та же, что у
;;; первого аргумента.

 ; Например,
;;; (same-parity 1 2 3 4 5 6 7)
;;; (1 3 5 7)
;;; (same-parity 2 3 4 5 6 7)
;;; (2 4 6)

; Решение
(define (same-parity . n)
	(let ((reference-num (is-even? (car n))))
		(define (iter items newlist)
			(if (null? items)
					(reverse newlist)
					(if (= reference-num (is-even? (car items)))
							(iter (cdr items) (cons (car items) newlist))
							(iter (cdr items) newlist))))
		(iter n null)))
		
; экспорт процедуры
(provide same-parity)




