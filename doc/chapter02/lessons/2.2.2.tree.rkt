#lang racket/base
;;; Чтобы реализовать count-leaves, вспомним рекурсивную схему вычисления length:
;;; • Длина списка x есть 1 плюс длина cdr от x.
;;; • Длина пустого списка есть 0.
;;; Count-leaves очень похожа на эту схему. Значение для пустого списка остается
;;; тем же:
;;; • Count-leaves от пустого списка равна 0.
;;; Однако в шаге редукции, когда мы выделяем car списка, нам нужно учесть, что
;;; car сам по себе может быть деревом, листья которого нам требуется сосчитать. Таким
;;; образом, шаг редукции таков:
;;; • Count-leaves от дерева x есть count-leaves от (car x) плюс count-
;;; leaves от (cdr x).
;;; Наконец, вычисляя car-ы, мы достигаем листьев, так что нам требуется еще один
;;; базовый случай:

(define (length items)
 	(if (null? items)
 			0
 			(+ 1 (length (cdr items)))))

;;; Писать рекурсивные процедуры над деревьями в Scheme помогает элементарный пре-
;;; дикат pair?, который проверяет, является ли его аргумент парой. Вот процедура цели-
;;; ком  :

(define list1 (cons (list 1 2) (list 3 4)))
(length list1)

(define (count-leaves x)
	(cond ((null? x) 0)
				((not (pair? x)) 1)
				(else (+ (count-leaves (car x)) 
								 (count-leaves (cdr x))))))
(count-leaves list1)

(length (list 1 (list 2 (list 3 4))))